use crate::{
    arithmetic::virt_poly::hp_interface::{HPVirtualPolynomial, VPAuxInfo},
    errors::SnarkResult,
    piop::structs::{SumcheckProverState, SumcheckVerifierState},
    transcript::Tr,
};
use ark_ff::PrimeField;
use ark_std::{end_timer, start_timer};
use macros::timed;
use std::{fmt::Debug, marker::PhantomData};

use super::structs::SumcheckProof;

mod prover;
mod verifier;
#[derive(Clone, Debug, Default, Copy, PartialEq, Eq)]
/// Struct for PolyIOP protocol.
/// It has an associated type `F` that defines the prime field the multi-variate
/// polynomial operates on.
///
/// An PolyIOP may be instantiated with one of the following:
/// - SumCheck protocol.
/// - ZeroCheck protocol.
/// - PermutationCheck protocol.
///
/// Those individual protocol may have similar or identical APIs.
/// The systematic way to invoke specific protocol is, for example
///     `<PolyIOP<F> as SumCheck<F>>::prove()`
pub struct SumCheck<F: PrimeField> {
    /// Associated field
    #[doc(hidden)]
    phantom: PhantomData<F>,
}

/// A SumCheckSubClaim is a claim generated by the verifier at the end of
/// verification when it is convinced.
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct SumCheckSubClaim<F: PrimeField> {
    /// the multi-dimensional point that this multilinear extension is evaluated
    /// to
    pub point: Vec<F>,
    /// the expected evaluation
    pub expected_evaluation: F,
}

impl<F: PrimeField> SumCheck<F> {
    #[timed]
    fn extract_sum(proof: &SumcheckProof<F>) -> F {
        let res = proof.proofs[0].evaluations[0] + proof.proofs[0].evaluations[1];
        res
    }

    #[timed]
    fn init_transcript() -> Tr<F> {
        let res = Tr::<F>::new(b"Initializing SumCheck transcript");
        res
    }

    #[timed]
    pub fn prove(
        poly: &HPVirtualPolynomial<F>,
        transcript: &mut Tr<F>,
    ) -> SnarkResult<SumcheckProof<F>> {
        transcript.append_serializable_element(b"aux info", &poly.aux_info)?;

        let mut prover_state = SumcheckProverState::prover_init(poly)?;
        let mut challenge = None;
        let mut prover_msgs = Vec::with_capacity(poly.aux_info.num_variables);
        for _ in 0..poly.aux_info.num_variables {
            let prover_msg =
                SumcheckProverState::prove_round_and_update_state(&mut prover_state, &challenge)?;
            transcript.append_serializable_element(b"prover msg", &prover_msg)?;
            prover_msgs.push(prover_msg);
            challenge = Some(transcript.get_and_append_challenge(b"Internal round")?);
        }
        // pushing the last challenge point to the state
        if let Some(p) = challenge {
            prover_state.challenges.push(p)
        };

        Ok(SumcheckProof {
            point: prover_state.challenges,
            proofs: prover_msgs,
        })
    }

    pub fn verify(
        claimed_sum: F,
        proof: &SumcheckProof<F>,
        aux_info: &VPAuxInfo<F>,
        transcript: &mut Tr<F>,
    ) -> SnarkResult<SumCheckSubClaim<F>> {
        transcript.append_serializable_element(b"aux info", aux_info)?;
        let mut verifier_state = SumcheckVerifierState::verifier_init(aux_info);
        for i in 0..aux_info.num_variables {
            let prover_msg = proof.proofs.get(i).expect("proof is incomplete");
            transcript.append_serializable_element(b"prover msg", prover_msg)?;
            SumcheckVerifierState::verify_round_and_update_state(
                &mut verifier_state,
                prover_msg,
                transcript,
            )?;
        }

        let res = SumcheckVerifierState::check_and_generate_subclaim(&verifier_state, &claimed_sum);
        res
    }
}
