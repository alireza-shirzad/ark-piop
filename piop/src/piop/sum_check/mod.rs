use crate::{
    arithmetic::{
        ark_ff::PrimeField,
        mle::virt::{VPAuxInfo, VirtualPolynomial},
    },
    errors::DbSnResult,
    piop::structs::{SumcheckProverState, SumcheckVerifierState},
    transcript::Tr,
};
use ark_std::{end_timer, start_timer};
use macros::timed;
use std::{fmt::Debug, marker::PhantomData, sync::Arc};

use super::structs::SumcheckProof;

mod prover;
mod verifier;
#[derive(Clone, Debug, Default, Copy, PartialEq, Eq)]
/// Struct for PolyIOP protocol.
/// It has an associated type `F` that defines the prime field the multi-variate
/// polynomial operates on.
///
/// An PolyIOP may be instantiated with one of the following:
/// - SumCheck protocol.
/// - ZeroCheck protocol.
/// - PermutationCheck protocol.
///
/// Those individual protocol may have similar or identical APIs.
/// The systematic way to invoke specific protocol is, for example
///     `<PolyIOP<F> as SumCheck<F>>::prove()`
pub struct SumCheck<F: PrimeField> {
    /// Associated field
    #[doc(hidden)]
    phantom: PhantomData<F>,
}

/// A SumCheckSubClaim is a claim generated by the verifier at the end of
/// verification when it is convinced.
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct SumCheckSubClaim<F: PrimeField> {
    /// the multi-dimensional point that this multilinear extension is evaluated
    /// to
    pub point: Vec<F>,
    /// the expected evaluation
    pub expected_evaluation: F,
}

impl<F: PrimeField> SumCheck<F> {
    // type SumCheckProof = IOPProof<F>;
    // type VirtualPolynomial = VirtualPolynomial<F>;
    // type VPAuxInfo = VPAuxInfo<F>;
    // type MultilinearExtension = Arc<MLE<F>>;
    // type SumCheckSubClaim = SumCheckSubClaim<F>;
    // type Transcript = Tr<F>;

    #[timed]
    fn extract_sum(proof: &SumcheckProof<F>) -> F {
        let res = proof.proofs[0].evaluations[0] + proof.proofs[0].evaluations[1];
        res
    }

    #[timed]
    fn init_transcript() -> Tr<F> {
        let res = Tr::<F>::new(b"Initializing SumCheck transcript");
        res
    }

    #[timed]
    pub fn prove(
        poly: &VirtualPolynomial<F>,
        transcript: &mut Tr<F>,
    ) -> DbSnResult<SumcheckProof<F>> {
        transcript.append_serializable_element(b"aux info", &poly.aux_info)?;

        let mut prover_state = SumcheckProverState::prover_init(poly)?;
        let mut challenge = None;
        let mut prover_msgs = Vec::with_capacity(poly.aux_info.num_variables);
        for _ in 0..poly.aux_info.num_variables {
            let prover_msg =
                SumcheckProverState::prove_round_and_update_state(&mut prover_state, &challenge)?;
            transcript.append_serializable_element(b"prover msg", &prover_msg)?;
            prover_msgs.push(prover_msg);
            challenge = Some(transcript.get_and_append_challenge(b"Internal round")?);
        }
        // pushing the last challenge point to the state
        if let Some(p) = challenge {
            prover_state.challenges.push(p)
        };

        Ok(SumcheckProof {
            point: prover_state.challenges,
            proofs: prover_msgs,
        })
    }

    pub fn verify(
        claimed_sum: F,
        proof: &SumcheckProof<F>,
        aux_info: &VPAuxInfo<F>,
        transcript: &mut Tr<F>,
    ) -> DbSnResult<SumCheckSubClaim<F>> {
        transcript.append_serializable_element(b"aux info", aux_info)?;
        let mut verifier_state = SumcheckVerifierState::verifier_init(aux_info);
        for i in 0..aux_info.num_variables {
            let prover_msg = proof.proofs.get(i).expect("proof is incomplete");
            transcript.append_serializable_element(b"prover msg", prover_msg)?;
            SumcheckVerifierState::verify_round_and_update_state(
                &mut verifier_state,
                prover_msg,
                transcript,
            )?;
        }

        let res = SumcheckVerifierState::check_and_generate_subclaim(&verifier_state, &claimed_sum);
        res
    }
}

#[cfg(test)]
mod test {

    use crate::arithmetic::{ark_poly::MultilinearExtension, mle::mat::MLE};
    use ark_std::{UniformRand, test_rng};
    use ark_test_curves::bls12_381::Fr;

    use super::*;
    use std::sync::Arc;

    fn test_sumcheck(
        nv: usize,
        num_multiplicands_range: (usize, usize),
        num_products: usize,
    ) -> DbSnResult<()> {
        let mut rng = test_rng();
        let mut transcript = SumCheck::<Fr>::init_transcript();

        let (poly, asserted_sum) =
            VirtualPolynomial::rand(nv, num_multiplicands_range, num_products, &mut rng)?;
        let proof = SumCheck::<Fr>::prove(&poly, &mut transcript)?;
        let poly_info = poly.aux_info.clone();
        let mut transcript = SumCheck::<Fr>::init_transcript();
        let subclaim = SumCheck::<Fr>::verify(asserted_sum, &proof, &poly_info, &mut transcript)?;
        assert!(
            poly.evaluate(&subclaim.point).unwrap() == subclaim.expected_evaluation,
            "wrong subclaim"
        );
        Ok(())
    }

    fn test_sumcheck_internal(
        nv: usize,
        num_multiplicands_range: (usize, usize),
        num_products: usize,
    ) -> DbSnResult<()> {
        let mut rng = test_rng();
        let (poly, asserted_sum) =
            VirtualPolynomial::<Fr>::rand(nv, num_multiplicands_range, num_products, &mut rng)?;
        let poly_info = poly.aux_info.clone();
        let mut prover_state = SumcheckProverState::prover_init(&poly)?;
        let mut verifier_state = SumcheckVerifierState::verifier_init(&poly_info);
        let mut challenge = None;
        let mut transcript = Tr::new(b"a test transcript");
        transcript
            .append_message(b"testing", b"initializing transcript for testing")
            .unwrap();
        for _ in 0..poly.aux_info.num_variables {
            let prover_message =
                SumcheckProverState::prove_round_and_update_state(&mut prover_state, &challenge)
                    .unwrap();

            challenge = Some(
                SumcheckVerifierState::verify_round_and_update_state(
                    &mut verifier_state,
                    &prover_message,
                    &mut transcript,
                )
                .unwrap(),
            );
        }
        let subclaim =
            SumcheckVerifierState::check_and_generate_subclaim(&verifier_state, &asserted_sum)
                .expect("fail to generate subclaim");
        assert!(
            poly.evaluate(&subclaim.point).unwrap() == subclaim.expected_evaluation,
            "wrong subclaim"
        );
        Ok(())
    }

    #[test]
    fn test_trivial_polynomial() -> DbSnResult<()> {
        let nv = 1;
        let num_multiplicands_range = (4, 13);
        let num_products = 5;

        test_sumcheck(nv, num_multiplicands_range, num_products)?;
        test_sumcheck_internal(nv, num_multiplicands_range, num_products)
    }
    #[test]
    fn test_normal_polynomial() -> DbSnResult<()> {
        let nv = 12;
        let num_multiplicands_range = (4, 9);
        let num_products = 5;

        test_sumcheck(nv, num_multiplicands_range, num_products)?;
        test_sumcheck_internal(nv, num_multiplicands_range, num_products)
    }
    #[test]
    fn zero_polynomial_should_error() {
        let nv = 0;
        let num_multiplicands_range = (4, 13);
        let num_products = 5;

        assert!(test_sumcheck(nv, num_multiplicands_range, num_products).is_err());
        assert!(test_sumcheck_internal(nv, num_multiplicands_range, num_products).is_err());
    }

    #[test]
    fn test_extract_sum() -> DbSnResult<()> {
        let mut rng = test_rng();
        let mut transcript = SumCheck::<Fr>::init_transcript();
        let (poly, asserted_sum) = VirtualPolynomial::<Fr>::rand(8, (3, 4), 3, &mut rng)?;

        let proof = SumCheck::<Fr>::prove(&poly, &mut transcript)?;
        assert_eq!(SumCheck::<Fr>::extract_sum(&proof), asserted_sum);
        Ok(())
    }

    #[test]
    /// Test that the memory usage of shared-reference is linear to number of
    /// unique MLExtensions instead of total number of multiplicands.
    fn test_shared_reference() -> DbSnResult<()> {
        let mut rng = test_rng();
        let ml_extensions: Vec<_> = (0..5)
            .map(|_| Arc::new(MLE::<Fr>::rand(8, &mut rng)))
            .collect();
        let mut poly = VirtualPolynomial::new(8);
        poly.add_mle_list(
            vec![
                ml_extensions[2].clone(),
                ml_extensions[3].clone(),
                ml_extensions[0].clone(),
            ],
            Fr::rand(&mut rng),
        )?;
        poly.add_mle_list(
            vec![
                ml_extensions[1].clone(),
                ml_extensions[4].clone(),
                ml_extensions[4].clone(),
            ],
            Fr::rand(&mut rng),
        )?;
        poly.add_mle_list(
            vec![
                ml_extensions[3].clone(),
                ml_extensions[2].clone(),
                ml_extensions[1].clone(),
            ],
            Fr::rand(&mut rng),
        )?;
        poly.add_mle_list(
            vec![ml_extensions[0].clone(), ml_extensions[0].clone()],
            Fr::rand(&mut rng),
        )?;
        poly.add_mle_list(vec![ml_extensions[4].clone()], Fr::rand(&mut rng))?;

        assert_eq!(poly.flattened_ml_extensions.len(), 5);

        // test memory usage for prover
        let prover = SumcheckProverState::<Fr>::prover_init(&poly).unwrap();
        assert_eq!(prover.poly.flattened_ml_extensions.len(), 5);
        drop(prover);

        let mut transcript = SumCheck::<Fr>::init_transcript();
        let poly_info = poly.aux_info.clone();
        let proof = SumCheck::<Fr>::prove(&poly, &mut transcript)?;
        let asserted_sum = SumCheck::<Fr>::extract_sum(&proof);

        let mut transcript = SumCheck::<Fr>::init_transcript();
        let subclaim = SumCheck::<Fr>::verify(asserted_sum, &proof, &poly_info, &mut transcript)?;
        assert!(
            poly.evaluate(&subclaim.point)? == subclaim.expected_evaluation,
            "wrong subclaim"
        );
        Ok(())
    }
}
