use super::structs::{
    ProcessedProvingKey, ProverState,
    proof::{PCSSubproof, Proof},
};
use crate::prover::tracker::SnarkError::ProverError;
use crate::prover::{errors::HonestProverError::FalseClaim, structs::TrackerEvalClaim};
use crate::prover::{errors::ProverError::HonestProverError, structs::polynomial::TrackedPoly};
use crate::{
    arithmetic::{
        mat_poly::{
            lde::LDE,
            mle::MLE,
            utils::{build_eq_x_r, evaluate_opt},
        },
        virt_poly::{
            VirtualPoly,
            hp_interface::{HPVirtualPolynomial, VPAuxInfo},
        },
    },
    errors::{SnarkError, SnarkResult},
    pcs::PCS,
    piop::{structs::SumcheckProof, sum_check::SumCheck},
    setup::{
        errors::SetupError::NoRangePoly,
        structs::{ProvingKey, VerifyingKey},
    },
    structs::{
        PCSOpeningProof, SumcheckSubproof, TrackerID,
        claim::{TrackerSumcheckClaim, TrackerZerocheckClaim},
    },
};
use ark_ff::PrimeField;
use ark_poly::Polynomial;
use ark_std::cfg_iter;
use derivative::Derivative;

#[cfg(feature = "parallel")]
use rayon::iter::{IntoParallelRefIterator, ParallelIterator};
use std::{
    collections::{BTreeMap, BTreeSet, HashSet},
    mem::take,
    panic,
    sync::Arc,
};
use tracing::{debug, instrument};
/// The Tracker is a data structure for creating and managing virtual
/// polynomials and their comitments. It is in charge of  
///                      1) Recording the structure of virtual polynomials and
///                         their products
///                      2) Recording the structure of virtual polynomials and
///                         their products
///                      3) Recording the comitments of virtual polynomials and
///                         their products
///                      4) Providing methods for adding virtual polynomials
///                         together

// Clone is only implemented if PCS satisfies the PCS<F>
// bound, which guarantees that PCS::ProverParam
#[derive(Derivative)]
#[derivative(Clone(bound = ""))]
// #[derivative(Clone(bound = "MvPCS: Clone, UvPCS: Clone"))]
pub struct ProverTracker<F, MvPCS, UvPCS>
where
    F: PrimeField,
    MvPCS: PCS<F, Poly = MLE<F>>,
    UvPCS: PCS<F, Poly = LDE<F>>,
{
    pub pk: ProcessedProvingKey<F, MvPCS, UvPCS>,
    pub state: ProverState<F, MvPCS, UvPCS>,
}

impl<F, MvPCS, UvPCS> ProverTracker<F, MvPCS, UvPCS>
where
    F: PrimeField,
    MvPCS: PCS<F, Poly = MLE<F>>,
    UvPCS: PCS<F, Poly = LDE<F>>,
{
    pub fn new_from_pk(pk: ProvingKey<F, MvPCS, UvPCS>) -> Self {
        let mut tracker = Self {
            pk: ProcessedProvingKey::new_from_pk(&pk),
            state: ProverState::default(),
        };
        tracker.add_vk_to_transcript(pk.vk.clone());
        tracker
    }

    fn add_vk_to_transcript(&mut self, vk: VerifyingKey<F, MvPCS, UvPCS>) {
        self.state
            .transcript
            .append_serializable_element(b"vk", &vk)
            .unwrap();
        vk.indexed_coms.iter().for_each(|(_, comm)| {
            self.state
                .transcript
                .append_serializable_element(b"comm", comm)
                .unwrap();
        });
    }

    pub fn set_indexed_tracked_polys(
        &mut self,
        range_tr_polys: BTreeMap<String, TrackedPoly<F, MvPCS, UvPCS>>,
    ) {
        self.pk.indexed_mles = range_tr_polys;
    }

    /// Get the range tracked polynomial given the data type
    pub fn indexed_tracked_poly(&self, label: String) -> SnarkResult<TrackedPoly<F, MvPCS, UvPCS>> {
        match self.pk.indexed_mles.get(&label) {
            Some(poly) => Ok(poly.clone()),
            _ => Err(SnarkError::SetupError(NoRangePoly(format!("{:?}", label)))),
        }
    }

    /// Generates a new `TrackerID`.
    ///
    /// This function increments an internal counter and returns a new
    /// `TrackerID` based on the current value of the counter. It ensures
    /// that each generated `TrackerID` is unique.
    pub fn gen_id(&mut self) -> TrackerID {
        let id = self.state.num_tracked_polys;
        self.state.num_tracked_polys += 1;
        TrackerID(id)
    }

    /// Peek at the next `TrackerID` that will be generated by gen_id.
    pub fn next_id(&mut self) -> TrackerID {
        TrackerID(self.state.num_tracked_polys)
    }

    // Peek at the next TrackerID without incrementing the counter
    pub(crate) fn peek_next_id(&mut self) -> TrackerID {
        TrackerID(self.state.num_tracked_polys)
    }

    /// Tracks a materialized polynomial.
    ///
    /// moves the polynomial to heap, assigns a TracckerID to it in map and
    /// returns the TrackerID
    pub fn track_mat_mv_poly(&mut self, polynomial: MLE<F>) -> TrackerID {
        let polynomial = Arc::new(polynomial);
        self.track_mat_arc_mv_poly(polynomial)
    }

    /// Tracks a materialized polynomial.
    ///
    /// moves the polynomial to heap, assigns a TracckerID to it in map and
    /// returns the TrackerID
    pub fn track_mat_uv_poly(&mut self, polynomial: LDE<F>) -> TrackerID {
        let polynomial = Arc::new(polynomial);
        self.track_mat_arc_uv_poly(polynomial)
    }
    /// Tracks materialized polynomial by reference.
    ///
    /// Assumes the input polynomial is already on the heap and assigns a
    /// TrackerID to it in the map
    fn track_mat_arc_mv_poly(&mut self, polynomial: Arc<MLE<F>>) -> TrackerID {
        // Create the new TrackerID
        let poly_id = self.gen_id();

        // Add the polynomial to the materialized map
        self.state
            .mv_pcs_substate
            .materialized_polys
            .insert(poly_id, polynomial.clone());
        // Return the new TrackerID
        poly_id
    }

    fn track_mat_arc_uv_poly(&mut self, polynomial: Arc<LDE<F>>) -> TrackerID {
        // Create the new TrackerID
        let poly_id = self.gen_id();

        // Add the polynomial to the materialized map
        self.state
            .uv_pcs_substate
            .materialized_polys
            .insert(poly_id, polynomial.clone());

        // Return the new TrackerID
        poly_id
    }

    /// Tracks a materialized polynomial and sends a commitment to the verifier.
    pub fn track_and_commit_mat_mv_p(&mut self, polynomial: &MLE<F>) -> SnarkResult<TrackerID> {
        let polynomial = Arc::new(polynomial.clone());
        // commit to the polynomial
        let commitment = MvPCS::commit(self.pk.mv_pcs_param.as_ref(), &polynomial)?;
        Self::track_mat_mv_p_and_commitment(self, &polynomial, commitment)
    }

    pub fn track_mat_mv_p_and_commitment(
        &mut self,
        polynomial: &MLE<F>,
        commitment: MvPCS::Commitment,
    ) -> SnarkResult<TrackerID> {
        let polynomial = Arc::new(polynomial.clone());
        // commit to the polynomial

        // track the polynomial and get its id
        let poly_id = self.track_mat_arc_mv_poly(polynomial);

        // add the commitment to the commitment map with the same poly_id
        self.state
            .mv_pcs_substate
            .materialized_comms
            .insert(poly_id, commitment.clone());

        // Add the commitment to the transcript, since it will be sent to the verifier
        self.state
            .transcript
            .append_serializable_element(b"comm", &commitment)?;
        // Return the new TrackerID
        Ok(poly_id)
    }

    pub fn track_and_commit_mat_uv_poly(&mut self, polynomial: LDE<F>) -> SnarkResult<TrackerID> {
        let polynomial = Arc::new(polynomial);
        // commit to the polynomial
        let commitment = UvPCS::commit(self.pk.uv_pcs_param.as_ref(), &polynomial)?;
        Self::track_mat_uv_p_and_commitment(self, &polynomial, commitment)
    }

    fn track_mat_uv_p_and_commitment(
        &mut self,
        polynomial: &LDE<F>,
        commitment: UvPCS::Commitment,
    ) -> SnarkResult<TrackerID> {
        let polynomial = Arc::new(polynomial.clone());

        // track the polynomial and get its id
        let poly_id = self.track_mat_arc_uv_poly(polynomial);

        // add the commitment to the commitment map with the same poly_id
        self.state
            .uv_pcs_substate
            .materialized_comms
            .insert(poly_id, commitment.clone());

        // Add the commitment to the transcript, since it will be sent to the verifier
        self.state
            .transcript
            .append_serializable_element(b"comm", &commitment)?;
        // Return the new TrackerID
        Ok(poly_id)
    }

    /// Tracks a virtual polynomial
    ///
    /// generates a new TrackerID and adds the virtual polynomial to the map
    fn track_virt_poly(&mut self, virt: VirtualPoly<F>) -> TrackerID {
        let poly_id = self.gen_id();
        self.state.virtual_polys.insert(poly_id, virt);
        // No need to commit to virtual polynomials
        poly_id
    }

    /// Get a reference to a materialized multivariate polynomial on the heap,
    /// from the map, by its TrackerID
    pub fn mat_mv_poly(&self, id: TrackerID) -> Option<&Arc<MLE<F>>> {
        self.state.mv_pcs_substate.materialized_polys.get(&id)
    }

    /// Get a reference to a materialized univariate polynomial on the heap,
    /// from the map, by its TrackerID
    pub fn mat_uv_poly(&self, id: TrackerID) -> Option<&Arc<LDE<F>>> {
        self.state.uv_pcs_substate.materialized_polys.get(&id)
    }

    /// Get a virtual polynomial, from the map, by its TrackerID
    pub fn virt_poly(&self, id: TrackerID) -> Option<&VirtualPoly<F>> {
        self.state.virtual_polys.get(&id)
    }
    fn extract_mv_openable_ids(&self, id: TrackerID) -> BTreeSet<TrackerID> {
        if self
            .state
            .mv_pcs_substate
            .materialized_comms
            .contains_key(&id)
        {
            return BTreeSet::from([id]);
        }
        let poly = self.virt_poly(id).unwrap();
        // 1)  Initialise the DFS stack with every TrackerID mentioned up-front
        let mut stack: Vec<TrackerID> = poly
            .iter()
            .flat_map(|(_, ids)| ids.iter().copied())
            .collect();

        let mut openable = BTreeSet::new();
        let mut visited = HashSet::new();

        // 2)  Standard iterative DFS
        while let Some(id) = stack.pop() {
            if !visited.insert(id) {
                continue; // already explored
            }

            // a) leaf with concrete commitment?
            if self
                .state
                .mv_pcs_substate
                .materialized_comms
                .contains_key(&id)
            {
                openable.insert(id);
                continue; // do *not* push children
            }

            // b) otherwise follow the virtual-poly reference if it exists
            if let Some(vpoly) = self.state.virtual_polys.get(&id) {
                for (_, child_ids) in vpoly {
                    stack.extend(child_ids.iter().copied());
                }
            }
            // c) dangling reference ⇒ silently ignore
        }

        openable
    }

    fn extract_uv_openable_ids(&self, id: TrackerID) -> BTreeSet<TrackerID> {
        if self
            .state
            .uv_pcs_substate
            .materialized_comms
            .contains_key(&id)
        {
            return BTreeSet::from([id]);
        }
        let poly = self.virt_poly(id).unwrap();
        // 1)  Initialise the DFS stack with every TrackerID mentioned up-front
        let mut stack: Vec<TrackerID> = poly
            .iter()
            .flat_map(|(_, ids)| ids.iter().copied())
            .collect();

        let mut openable = BTreeSet::new();
        let mut visited = HashSet::new();

        // 2)  Standard iterative DFS
        while let Some(id) = stack.pop() {
            if !visited.insert(id) {
                continue; // already explored
            }

            // a) leaf with concrete commitment?
            if self
                .state
                .uv_pcs_substate
                .materialized_comms
                .contains_key(&id)
            {
                openable.insert(id);
                continue; // do *not* push children
            }

            // b) otherwise follow the virtual-poly reference if it exists
            if let Some(vpoly) = self.state.virtual_polys.get(&id) {
                for (_, child_ids) in vpoly {
                    stack.extend(child_ids.iter().copied());
                }
            }
            // c) dangling reference ⇒ silently ignore
        }

        openable
    }

    /// Get the number of variables of a polynomial, by its TrackerID
    pub fn poly_nv(&self, id: TrackerID) -> usize {
        // If it's materialized, simply return the number of variables
        let mat_poly = self.state.mv_pcs_substate.materialized_polys.get(&id);

        if let Some(mat_poly) = mat_poly {
            return mat_poly.num_vars();
        }

        // look up the virtual polynomial
        let virt_poly = self.state.virtual_polys.get(&id);
        if virt_poly.is_none() {
            panic!("Unknown poly id: {:?}", id);
        }
        let virt_poly: &VirtualPoly<F> = virt_poly.unwrap(); // Invariant: contains only material PolyIDs //TODO: Why?

        // TODO: Wouldn't it be better to store the number of variables in the virtual
        // polynomial?
        // figure out the number of variables, assume they all have
        // this nv Get the nv from the first polynomial of the first term of the
        // virtual polynomial This polynomial might itself be virtual, so we
        // need to recurse
        let first_id = virt_poly[0].1[0];
        let nv: usize = self.mat_mv_poly(first_id).unwrap().num_vars();
        nv
    }

    /// Adds/Subtracts two polynomials together
    /// The two polynomials are identified by their TrackerIDs, Each one can be
    /// either materialized or virtual
    /// The output is a tracker to a new virtual polynomial
    pub fn add_sub_polys(&mut self, p1_id: TrackerID, p2_id: TrackerID, do_sub: bool) -> TrackerID {
        let sign_coeff: F = if do_sub { F::one().neg() } else { F::one() };

        let p1_mat = self.mat_mv_poly(p1_id);
        let p1_virt = self.virt_poly(p1_id);
        let p2_mat = self.mat_mv_poly(p2_id);
        let p2_virt = self.virt_poly(p2_id);

        let mut new_virt_rep: VirtualPoly<F> = Vec::new(); // Invariant: contains only material TrackerIDs
        match (
            p1_mat.is_some(),
            p1_virt.is_some(),
            p2_mat.is_some(),
            p2_virt.is_some(),
        ) {
            // Bad Case: p1 not found
            (false, false, ..) => {
                panic!("Unknown p1 TrackerID {:?}", p1_id);
            }
            // Bad Case: p2 not found
            (_, _, false, false) => {
                panic!("Unknown p2 TrackerID {:?}", p2_id);
            }
            // Case 1: both p1 and p2 are materialized
            (true, false, true, false) => {
                new_virt_rep.push((F::one(), vec![p1_id]));
                new_virt_rep.push((sign_coeff, vec![p2_id]));
            }
            // Case 2: p1 is materialized and p2 is virtual
            (true, false, false, true) => {
                new_virt_rep.push((F::one(), vec![p1_id]));
                p2_virt.unwrap().iter().for_each(|(coeff, prod)| {
                    new_virt_rep.push((sign_coeff * *coeff, prod.clone()));
                });
            }
            // Case 3: p2 is materialized and p1 is virtual
            (false, true, true, false) => {
                p1_virt.unwrap().iter().for_each(|(coeff, prod)| {
                    new_virt_rep.push((*coeff, prod.clone()));
                });
                new_virt_rep.push((sign_coeff, vec![p2_id]));
            }
            // Case 4: both p1 and p2 are virtual
            (false, true, false, true) => {
                p1_virt.unwrap().iter().for_each(|(coeff, prod)| {
                    new_virt_rep.push((*coeff, prod.clone()));
                });
                p2_virt.unwrap().iter().for_each(|(coeff, prod)| {
                    new_virt_rep.push((sign_coeff * *coeff, prod.clone()));
                });
            }
            // Handling unexpected cases
            _ => {
                panic!("Internal tracker::add_polys error. This code should be unreachable");
            }
        }
        self.track_virt_poly(new_virt_rep)
    }

    /// Adds two polynomials together
    /// The two polynomials are identified by their TrackerIDs, Each one can be
    /// either materialized or virtual
    /// The output is a tracker to a new virtual polynomial
    pub fn add_polys(&mut self, p1_id: TrackerID, p2_id: TrackerID) -> TrackerID {
        self.add_sub_polys(p1_id, p2_id, false)
    }

    /// Subtracts p2 from p1
    /// The two polynomials are identified by their TrackerIDs, Each one can be
    /// either materialized or virtual
    /// The output is a tracker to a new virtual polynomial
    pub fn sub_polys(&mut self, p1_id: TrackerID, p2_id: TrackerID) -> TrackerID {
        self.add_sub_polys(p1_id, p2_id, true)
    }

    /// Multiplies two polynomials together
    /// The two polynomials are identified by their TrackerIDs, Each one can be
    /// either materialized or virtual
    /// The output is a tracker to a new virtual polynomial
    pub fn mul_polys(&mut self, p1_id: TrackerID, p2_id: TrackerID) -> TrackerID {
        let p1_mat = self.mat_mv_poly(p1_id);
        let p1_virt = self.virt_poly(p1_id);
        let p2_mat = self.mat_mv_poly(p2_id);
        let p2_virt = self.virt_poly(p2_id);

        let mut new_virt_rep = Vec::new(); // Invariant: contains only material TrackerIDs
        match (
            p1_mat.is_some(),
            p1_virt.is_some(),
            p2_mat.is_some(),
            p2_virt.is_some(),
        ) {
            // Bad Case: p1 not found
            (false, false, ..) => {
                panic!("Unknown p1 TrackerID {:?}", p1_id);
            }
            // Bad Case: p2 not found
            (_, _, false, false) => {
                panic!("Unknown p2 TrackerID {:?}", p2_id);
            }
            // Case 1: both p1 and p2 are materialized
            (true, false, true, false) => {
                new_virt_rep.push((F::one(), vec![p1_id, p2_id]));
            }
            // Case 2: p1 is materialized and p2 is virtual
            (true, false, false, true) => {
                let p2_rep = p2_virt.unwrap();
                p2_rep.iter().for_each(|(coeff, prod)| {
                    let mut new_prod = prod.clone();
                    new_prod.push(p1_id);
                    new_virt_rep.push((*coeff, new_prod));
                });
            }
            // Case 3: p2 is materialized and p1 is virtual
            (false, true, true, false) => {
                let p1_rep = p1_virt.unwrap();
                p1_rep.iter().for_each(|(coeff, prod)| {
                    let mut new_prod = prod.clone();
                    new_prod.push(p2_id);
                    new_virt_rep.push((*coeff, new_prod));
                });
            }
            // Case 4: both p1 and p2 are virtual
            (false, true, false, true) => {
                let p1_rep = p1_virt.unwrap();
                let p2_rep = p2_virt.unwrap();
                p1_rep.iter().for_each(|(p1_coeff, p1_prod)| {
                    p2_rep.iter().for_each(|(p2_coeff, p2_prod)| {
                        let new_coeff = *p1_coeff * p2_coeff;
                        let mut new_prod_vec = p1_prod.clone();
                        new_prod_vec.extend(p2_prod.clone());
                        new_virt_rep.push((new_coeff, new_prod_vec));
                    })
                });
            }
            // Handling unexpected cases
            _ => {
                panic!("Internal tracker::mul_polys error. This code should be unreachable");
            }
        }
        self.track_virt_poly(new_virt_rep)
    }

    /// Adds a scalar to a polynomial, returns a new virtual polynomial
    // TODO: Can we do it more efficiently?
    pub fn add_scalar(&mut self, poly_id: TrackerID, c: F) -> TrackerID {
        let nv = self.poly_nv(poly_id);
        let scalar_mle = MLE::from_evaluations_vec(nv, vec![c; 2_usize.pow(nv as u32)]);
        let scalar_id = self.track_mat_mv_poly(scalar_mle);
        self.add_polys(poly_id, scalar_id)
    }

    /// Multiplies a polynomial by a scalar, returns a new virtual polynomial
    pub fn mul_scalar(&mut self, poly_id: TrackerID, c: F) -> TrackerID {
        let mut new_virt_rep = Vec::new(); // Invariant: contains only material TrackerIDs

        let p_mat = self.mat_mv_poly(poly_id);
        if p_mat.is_some() {
            new_virt_rep.push((c, vec![poly_id]));
        } else {
            let p_virt = self.virt_poly(poly_id);
            p_virt.unwrap().iter().for_each(|(coeff, prod)| {
                new_virt_rep.push((*coeff * c, prod.clone()));
            });
        }
        self.track_virt_poly(new_virt_rep)
    }

    fn materialize_poly(&mut self, id: TrackerID) -> Arc<MLE<F>> {
        // look up the virtual polynomial
        if let Some(mat_poly) = self.state.mv_pcs_substate.materialized_polys.get(&id) {
            return mat_poly.clone(); // already materialized
        }
        let virt_poly = match self.state.virtual_polys.get(&id) {
            Some(v) => v.clone(),
            None => panic!("Unknown poly id: {:?}", id),
        }; // Invariant: contains only material PolyIDs

        // figure out the number of variables, assume they all have this nv
        let first_id = virt_poly[0].1[0];
        let nv: usize = self.mat_mv_poly(first_id).unwrap().num_vars();

        // calculate the evaluation of each product list
        let prod_evaluations: Vec<Vec<F>> = virt_poly
            .iter()
            .map(|(coeff, prod)| {
                let mut res = vec![*coeff; 2_usize.pow(nv as u32)];
                prod.iter().for_each(|poly| {
                    let poly_evals = self.evaluations(*poly);
                    res = res
                        .iter()
                        .zip(poly_evals.iter())
                        .map(|(a, b)| *a * b)
                        .collect()
                });
                res
            })
            .collect();
        // sum the evaluations of each product list
        let mut evals = vec![F::zero(); 2_usize.pow(nv as u32)];
        prod_evaluations.iter().for_each(|prod_eval| {
            evals = evals
                .iter()
                .zip(prod_eval.iter())
                .map(|(a, b)| *a + b)
                .collect()
        });

        // cache the result by updating the materialized poly map
        Arc::new(MLE::from_evaluations_vec(nv, evals))
    }
    pub fn evaluate_uv(&self, id: TrackerID, pt: &F) -> Option<F> {
        let mat_poly = self.state.uv_pcs_substate.materialized_polys.get(&id);
        // TODO: Change this to_vec
        mat_poly.map(|poly| poly.evaluate(pt))
    }
    /// Evaluates a polynomial at a point
    pub fn evaluate_mv(&self, id: TrackerID, pt: &[F]) -> Option<F> {
        // if the poly is materialized, return the evaluation
        let mat_poly = self.state.mv_pcs_substate.materialized_polys.get(&id);
        // TODO: Change this to_vec
        if let Some(poly) = mat_poly {
            return Some(evaluate_opt(poly, pt));
        }

        // look up the virtual polynomial
        let virt_poly = self.state.virtual_polys.get(&id);
        if virt_poly.is_none() {
            panic!("Unknown poly id: {:?}", id);
        }
        let virt_poly = virt_poly.unwrap(); // Invariant: contains only material TrackerIDs

        // calculate the evaluation of each product list
        let prod_evals: Vec<F> = virt_poly
            .iter()
            .map(|(coeff, prod)| {
                let mut res = *coeff;
                prod.iter().for_each(|poly| {
                    res *= self.evaluate_mv(*poly, pt).unwrap();
                });
                res
            })
            .collect();

        // sum the evaluations of each product list
        let mut eval = F::zero();
        prod_evals.iter().for_each(|prod_eval| {
            eval += prod_eval;
        });

        // return the eval
        Some(eval)
    }

    /// Returns the evaluations of a polynomial on the boolean hypercube
    pub fn evaluations(&mut self, id: TrackerID) -> Vec<F> {
        // Ensure the polynomial is materialized before getting evaluations
        let mat_poly = self.materialize_poly(id);

        mat_poly.evaluations()
    }

    /// Generate the challenge from the current transcript
    /// and append it to the transcript.
    pub fn get_and_append_challenge(&mut self, label: &'static [u8]) -> SnarkResult<F> {
        self.state
            .transcript
            .get_and_append_challenge(label)
            .map_err(SnarkError::from)
    }

    /// Adds a sumcheck claim to the list of the sumcheck claims of the prover
    /// a sumcheck claim is of the form (poly_id, claimed_sum) which means that
    /// the prover claims that the sum of the evaluations of the polynomial with
    /// poly_id is claimed_sum
    // TODO: Remove the claimed_sum
    pub fn add_mv_sumcheck_claim(&mut self, poly_id: TrackerID, claimed_sum: F) -> SnarkResult<()> {
        #[cfg(feature = "honest-prover")]
        {
            let evals = self.evaluations(poly_id);
            if cfg_iter!(evals).sum::<F>() != claimed_sum {
                return Err(ProverError(HonestProverError(FalseClaim)));
            }
        }
        self.state
            .mv_pcs_substate
            .sum_check_claims
            .push(TrackerSumcheckClaim::new(poly_id, claimed_sum));
        Ok(())
    }

    /// Adds a zerocheck claim to the list of the zerocheck claims of the prover
    /// a zerocheck claim is of the form (poly_id) which means that the prover
    /// claims that the polynomial with poly_id evaluates to zero all over the
    /// boolean hypercube
    pub fn add_mv_zerocheck_claim(&mut self, poly_id: TrackerID) -> SnarkResult<()> {
        #[cfg(feature = "honest-prover")]
        {
            let evals = self.evaluations(poly_id);
            if cfg_iter!(evals).any(|eval| *eval != F::zero()) {
                return Err(ProverError(HonestProverError(FalseClaim)));
            }
        }
        self.state
            .mv_pcs_substate
            .zero_check_claims
            .push(TrackerZerocheckClaim::new(poly_id));
        Ok(())
    }

    /// Adds an evaluation claim to the list of the zerocheck claims of the
    /// prover a zerocheck claim is of the form (poly_id) which means that
    /// the prover claims that the polynomial with poly_id evaluates to zero
    /// all over the boolean hypercube
    pub fn add_uv_eval_claim(&mut self, poly_id: TrackerID, point: F) -> SnarkResult<()> {
        self.state
            .uv_pcs_substate
            .eval_claims
            .push(TrackerEvalClaim::new(poly_id, point));
        Ok(())
    }

    pub fn insert_miscellaneous_field(&mut self, key: String, field: F) {
        self.state.miscellaneous_field_elements.insert(key, field);
    }

    pub fn add_mv_eval_claim(&mut self, poly_id: TrackerID, point: &[F]) -> SnarkResult<()> {
        self.state
            .mv_pcs_substate
            .eval_claims
            .push(TrackerEvalClaim::new(poly_id, point.to_vec()));
        Ok(())
    }

    // TODO: Is this only used to be compatible with the hyperplonk code?
    pub(crate) fn to_hp_virtual_poly(&self, id: TrackerID) -> HPVirtualPolynomial<F> {
        let mat_poly = self.state.mv_pcs_substate.materialized_polys.get(&id);
        if let Some(poly) = mat_poly {
            return HPVirtualPolynomial::new_from_mle(poly, F::one());
        }

        let poly = self.state.virtual_polys.get(&id);
        if poly.is_none() {
            panic!("Unknown poly id: {:?}", id);
        }
        let poly = poly.unwrap(); // Invariant: contains only material PolyIDs
        if poly.is_empty() {
            return HPVirtualPolynomial::new(1);
        }
        let first_id = poly[0].1[0];
        let nv: usize = self.mat_mv_poly(first_id).unwrap().num_vars();

        let mut arith_virt_poly: HPVirtualPolynomial<F> = HPVirtualPolynomial::new(nv);
        for (prod_coef, prod) in poly.iter() {
            let prod_mle_list = prod
                .iter()
                .map(|poly_id| self.mat_mv_poly(*poly_id).unwrap().clone())
                .collect::<Vec<Arc<MLE<F>>>>();
            arith_virt_poly
                .add_mle_list(prod_mle_list, *prod_coef)
                .unwrap();
        }

        arith_virt_poly
    }

    /// Iterates through the materialized polynomials and increases the number
    /// of variables to the max number of variables in the tracker
    /// Used as a preprocessing step before batching polynomials,
    // TODO: This can be potentially reduced
    #[instrument(level = "debug", skip(self))]
    fn equalize_mat_poly_nv(&mut self) -> usize {
        // calculate the max nv
        let max_nv: usize = self
            .state
            .mv_pcs_substate
            .materialized_polys
            .values()
            .map(|p| p.num_vars())
            .max()
            .ok_or(1)
            .unwrap();
        debug!("Maximum nv = {}", max_nv);
        for poly in self.state.mv_pcs_substate.materialized_polys.values_mut() {
            let old_nv = poly.num_vars();
            if old_nv != max_nv {
                // TODO: Fix this, just change the nv instead of cloning
                let new_poly = Arc::new(MLE::new(poly.mat_mle().clone(), Some(max_nv)));
                *poly = new_poly;
            }
        }
        // update the sumcheck claims because resizing messes stuff up
        // TODO: Do this normalization on the verifier side also
        let old_sumcheck_claims = self.state.mv_pcs_substate.sum_check_claims.clone();
        let true_sums: Vec<F> = old_sumcheck_claims
            .iter()
            .map(|claim| self.evaluations(claim.id()).iter().sum::<F>())
            .collect();
        for (claim, &true_sum) in self
            .state
            .mv_pcs_substate
            .sum_check_claims
            .iter_mut()
            .zip(true_sums.iter())
        {
            claim.set_claim(true_sum);
        }

        for claim in self.state.mv_pcs_substate.eval_claims.iter_mut() {
            let mut point = claim.point().clone();
            point.resize(max_nv, F::zero());
            claim.set_point(point);
        }
        max_nv
    }

    /// converts all the zerocheck claims into a single zero claim
    /// technique: If p1=0, ..., pn=0, then c1*p1 + ... + cn*pn = 0 where ci-s
    /// are random. At the end of this function, there should only be one
    /// zerocheck claim in the prover state.
    #[instrument(level = "debug", skip(self))]
    fn batch_z_check_claims(&mut self) -> SnarkResult<()> {
        let num_claims = self.state.mv_pcs_substate.zero_check_claims.len();

        if (num_claims == 0) {
            debug!("No zerocheck claims to batch",);
            return Ok(());
        }

        // build the running aggregate polynomial
        let mut agg = self.track_virt_poly(Vec::new());
        // Perform the random linear combination and aggregate them
        agg = take(&mut self.state.mv_pcs_substate.zero_check_claims)
            .into_iter()
            .fold(agg, |acc, claim| {
                let ch = self
                    .get_and_append_challenge(b"zerocheck challenge")
                    .unwrap();
                let cp = self.mul_scalar(claim.id(), ch);
                self.add_polys(acc, cp)
            });

        // Push the new aggregated claim to the prover state as the inly zerocheck claim
        self.add_mv_zerocheck_claim(agg)?;
        debug!(
            "{} zerocheck claims were batched into 1 zerocheck claim",
            num_claims
        );
        Ok(())
    }

    // Aggregate the sumcheck claims, instead of proving p_1 = s_1, p_2 = s_2, ...
    // p_n = s_n, we prove c_1 * p_1 + c_2 * p_2 + ... + c_n * p_n = c_1 *
    // s_1 + c_2 * s_2 + ... + c_n * s_n where c_i-s are random challenges
    #[instrument(level = "debug", skip(self))]
    fn batch_s_check_claims(&mut self) -> SnarkResult<BTreeMap<TrackerID, F>> {
        let num_claims = self.state.mv_pcs_substate.sum_check_claims.len();

        if (num_claims == 0) {
            debug!("No sumcheck claims to batch",);
            return Ok(BTreeMap::new());
        }

        let mut agg = self.track_virt_poly(Vec::new());
        let mut sc_sum = F::zero();

        // Record the individual sumcheck claims to send to the verifier
        //TODO: This is only recorded for a specific protocol that uses this library and needs these, i.e. multiplicity-check. This should be removed from the library and added to the user-defined optional proof elements.
        let individual_sumcheck_claims: BTreeMap<TrackerID, F> = self
            .state
            .mv_pcs_substate
            .sum_check_claims
            .iter()
            .map(|claim| (claim.id(), claim.claim()))
            .collect();

        // Perform the random linear combination and aggregate them
        agg = take(&mut self.state.mv_pcs_substate.sum_check_claims)
            .into_iter()
            .fold(agg, |acc, claim| {
                let ch = self
                    .get_and_append_challenge(b"sumcheck challenge")
                    .unwrap();
                let cp = self.mul_scalar(claim.id(), ch);
                sc_sum += claim.claim() * ch;
                self.add_polys(acc, cp)
            });
        // Now the sumcheck claims are empty
        // Add the new aggregated sumcheck claim to the list of claims
        self.add_mv_sumcheck_claim(agg, sc_sum)?;
        debug!(
            "{} sumcheck claims were batched into 1 sumcheck claim",
            num_claims
        );
        Ok(individual_sumcheck_claims)
    }

    /// Convert the zerocheck claim to a sumcheck claim
    /// Note that at this point, there is only one batched
    /// zero-check
    /// Technique: Run a sumcheck over f'(X) = f(X) * eq(X, r) for a random
    /// challenge r
    #[instrument(level = "debug", skip(self))]
    fn z_check_claim_to_s_check_claim(&mut self, max_nv: usize) -> SnarkResult<()> {
        if (self.state.mv_pcs_substate.zero_check_claims.is_empty()) {
            debug!("No zerocheck claims to convert to sumcheck claims",);
            return Ok(());
        }
        // Check at this point there should be only one batched zero check claim
        debug_assert_eq!(self.state.mv_pcs_substate.zero_check_claims.len(), 1);
        // sample the random challenge r
        let r = self
            .state
            .transcript
            .get_and_append_challenge_vectors(b"0check r", max_nv)
            .unwrap();
        // Get the zero check claim polynomial id
        let z_check_aggr_id = self
            .state
            .mv_pcs_substate
            .zero_check_claims
            .last()
            .unwrap()
            .id();

        // build the eq(x, r) polynomial
        let eq_x_r_id = self.track_mat_arc_mv_poly(build_eq_x_r(r.as_ref()).unwrap());

        // create the relevant sumcheck claim, i.e. reduce the zerocheck claim to a
        // sumcheck claim
        let new_sc_claim_poly = self.mul_polys(z_check_aggr_id, eq_x_r_id);

        // Add this new sumcheck claim to other sumcheck claims
        self.add_mv_sumcheck_claim(new_sc_claim_poly, F::zero())?;
        debug!("The only zerocheck claim was converted to a sumcheck claim",);
        Ok(())
    }

    #[instrument(level = "debug", skip(self))]
    fn perform_single_sumcheck(&mut self) -> SnarkResult<(SumcheckProof<F>, VPAuxInfo<F>)> {
        debug_assert!(self.state.mv_pcs_substate.sum_check_claims.len() == 1);
        // Get the sumcheck claim polynomial id
        let sumcheck_aggr_id = self
            .state
            .mv_pcs_substate
            .sum_check_claims
            .last()
            .unwrap()
            .id();
        // Generate a sumcheck proof
        let sc_avp = self.to_hp_virtual_poly(sumcheck_aggr_id);
        let sc_aux_info = sc_avp.aux_info.clone();
        let sc_proof = SumCheck::prove(&sc_avp, &mut self.state.transcript)?;
        let _ = self.add_mv_eval_claim(sumcheck_aggr_id, &sc_proof.point);
        Ok((sc_proof, sc_aux_info))
    }

    /// Reduces every zero-check claim, sum-check claim in
    /// the prover state, into a list of evaluation claims. These evaluation
    /// claims will be proved using a PCS
    #[instrument(level = "debug", skip(self))]
    fn compile_sc_subproof(&mut self, max_nv: usize) -> SnarkResult<Option<SumcheckSubproof<F>>> {
        // Batch all the zero-check claims into one claim, remove old zerocheck claims
        self.batch_z_check_claims()?;
        // Convert the only zerocheck claim to a sumcheck claim
        self.z_check_claim_to_s_check_claim(max_nv)?;
        // Batch all the cumcheck claims into one sumcheck claims
        let individual_sumcheck_claims = self.batch_s_check_claims()?;
        if self.state.mv_pcs_substate.sum_check_claims.is_empty() {
            debug!("No sumcheck claims to prove",);
            return Ok(None);
        }
        // Perform the one batched sumcheck
        let (sc_proof, sc_aux_info) = self.perform_single_sumcheck()?;
        // Assemble the sumcheck subproof of the prover
        let sc_subproof = SumcheckSubproof::new(
            sc_proof.clone(),
            sc_aux_info.clone(),
            individual_sumcheck_claims,
        );
        Ok(Some(sc_subproof))
    }

    /// Compiles the PCS subproof, a proof containg (a) a list of comitments to
    /// the polynomials that the verifier needs oracle access to (b) a query
    /// map, which is the list of all the possible verifier queries to these
    /// comitments (c) a batch opening proof corresponding to the query map
    #[instrument(level = "debug", skip(self))]
    pub fn compile_mv_pcs_subproof(&mut self) -> SnarkResult<PCSSubproof<F, MvPCS>> {
        let mut query_map: BTreeMap<(TrackerID, Vec<F>), F> = BTreeMap::new();
        let mut mat_polys = Vec::new();
        let mut points = Vec::new();
        let mut evals = Vec::new();
        for claim in &self.state.mv_pcs_substate.eval_claims {
            let eval_id = claim.id();
            let eval_point = claim.point();
            let mat_ids = self.extract_mv_openable_ids(eval_id);
            for mat_id in mat_ids {
                let eval = self.evaluate_mv(mat_id, eval_point).unwrap();
                query_map.insert((mat_id, eval_point.clone()), eval);
                mat_polys.push(self.mat_mv_poly(mat_id).unwrap().clone());
                points.push(eval_point.clone());
                evals.push(eval);
            }
        }

        let opening_proof: PCSOpeningProof<F, MvPCS>;
        if mat_polys.len() == 1 {
            let single_proof = MvPCS::open(
                self.pk.mv_pcs_param.as_ref(),
                &mat_polys[0],
                &points[0],
                None,
            )?;
            opening_proof = PCSOpeningProof::SingleProof(single_proof.0);
            assert!(single_proof.1 == evals[0]);
        } else if mat_polys.len() > 1 {
            let batch_proof = MvPCS::multi_open(
                self.pk.mv_pcs_param.as_ref(),
                &mat_polys,
                &points,
                &evals,
                &mut self.state.transcript,
            )?;
            opening_proof = PCSOpeningProof::BatchProof(batch_proof);
        } else {
            opening_proof = PCSOpeningProof::Empty;
        }

        // Perform the batch-opening

        Ok(PCSSubproof {
            query_map,
            opening_proof,
            comitments: self.state.mv_pcs_substate.materialized_comms.clone(),
        })
    }

    /// Compiles the PCS subproof, a proof containg (a) a list of comitments to
    /// the polynomials that the verifier needs oracle access to (b) a query
    /// map, which is the list of all the possible verifier queries to these
    /// comitments (c) a batch opening proof corresponding to the query map
    #[instrument(level = "debug", skip(self))]
    pub fn compile_uv_pcs_subproof(&mut self) -> SnarkResult<PCSSubproof<F, UvPCS>> {
        let mut query_map: BTreeMap<(TrackerID, F), F> = BTreeMap::new();
        let mut mat_polys = Vec::new();
        let mut points = Vec::new();
        let mut evals = Vec::new();
        for claim in &self.state.uv_pcs_substate.eval_claims {
            let eval_id = claim.id();
            let eval_point = claim.point();
            let mat_ids = self.extract_uv_openable_ids(eval_id);
            for mat_id in mat_ids {
                let eval = self.evaluate_uv(mat_id, eval_point).unwrap();
                query_map.insert((mat_id, *eval_point), eval);
                mat_polys.push(self.mat_uv_poly(mat_id).unwrap().clone());
                points.push(*eval_point);
                evals.push(eval);
            }
        }

                let opening_proof: PCSOpeningProof<F, UvPCS>;
        if mat_polys.len() == 1 {
            let single_proof = UvPCS::open(
                self.pk.uv_pcs_param.as_ref(),
                &mat_polys[0],
                &points[0],
                None,
            )?;
            opening_proof = PCSOpeningProof::SingleProof(single_proof.0);
            assert!(single_proof.1 == evals[0]);
        } else if mat_polys.len() > 1 {
            let batch_proof = UvPCS::multi_open(
                self.pk.uv_pcs_param.as_ref(),
                &mat_polys,
                &points,
                &evals,
                &mut self.state.transcript,
            )?;
            opening_proof = PCSOpeningProof::BatchProof(batch_proof);
        } else {
            opening_proof = PCSOpeningProof::Empty;
        }

        // Perform the batch-opening

        Ok(PCSSubproof {
            query_map,
            opening_proof,
            comitments: self.state.uv_pcs_substate.materialized_comms.clone(),
        })
    }

    /// Compiled the final proof, which contains three subproofs:
    /// 1. The batched sumcheck subproof
    /// 2. The multivariate PCS subproof
    /// 3. The univariate PCS subproof
    #[instrument(level = "debug", skip(self))]
    pub fn compile_proof(&mut self) -> SnarkResult<Proof<F, MvPCS, UvPCS>>
    where
        MvPCS: PCS<F, Poly = MLE<F>>,
        UvPCS: PCS<F, Poly = LDE<F>>,
    {
        // Transform all the materialized polynomials to polynomials with the maximum
        // number of variables needed
        let max_nv = self.equalize_mat_poly_nv();
        // Assemble and output the final proof
        let proof = Proof {
            sc_subproof: self.compile_sc_subproof(max_nv)?,
            mv_pcs_subproof: self.compile_mv_pcs_subproof()?,
            uv_pcs_subproof: self.compile_uv_pcs_subproof()?,
            miscellaneous_field_elements: self.state.miscellaneous_field_elements.clone(),
        };
        self.state.miscellaneous_field_elements.clear();
        Ok(proof)
    }
}
